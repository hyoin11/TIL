## 복잡성 소개

### 들어가기 전에
많은 양의 데이터를 효율적으로 관리하기 위해 다양한 자료구조 및 알고리즘이 개발되어 왔다.   
하지만 이 효율적이라는 것의 기준은 무엇일까?   
프로그램의 복잡도를 계산하여 이러한 알고리즘을 비교하는 방법에 대해 살펴보도록 하자.

### 학습 목표
작성한 프로그램의 시간 복잡도를 계산하여 알고리즘의 효율성을 비교할 수 있다.

### 핵심 단어
- 시간 복잡도
- 알고리즘 비교

---
#### 시간복잡도
시간 복잡도는 서로 다른 알고리즘의 효율성을 비교할 때 사용한다.   
시간 복잡도에는 몇 가지 규칙이 있다. 

1. 입력값(n)은 항상 0보다 크다.  
   input >= 0   
   입력값이 음수일 수는 없다.


2. 함수는 많은 입력값이 있을 때 더 많은 작업을 하게 된다.   
   functions do more work for more input   
   더 많은 입력값이 주어지면 어떤 작업을 하는데 필요한 계산이나 처리 시간이 길어진다.


3. 시간 복잡도에서는 모든 상수를 삭제한다.   
   drop all constants   
   만약 어떤 알고리즘의 복잡도가 3n이라면 3은 고려하지 않고 복잡도는 n이 된다.   
   2n, 3n, 10n 모두 복잡도가 n인 알고리즘이다.


4. 낮은 차수의 항들은 무시한다.   
   시간 복잡도에서는 n과 n^2를 비교할 때에는 항상 n^2이 더 오래 걸리는 알고리즘이라고 판단한다.   
   여기서 의문이 들 수 있는 점은 그래프에서 (1,1)인 지점 전까지는 n이 더 오래걸릴 수 있다는 것이다.   
   하지만 알고리즘에서는 입력값(n)이 1보다 작은 값은 고려하지 않고 큰 값에 대해서만 생각하므로 n이 무한으로 커진 경우를 가정하고 비교해야한다.   
   이러한 이유로 시간 복잡도에서는 낮은 차수의 항들은 무시한다.   
   n^3 + n^2 + n 이라는 함수가 있을 때, n과 n^2는 알고리즘의 시간 복잡도에 영향을 미치지 않고, 입력값이 무한이 될 때 고려해야할 부분은 n^3이다.   
   이런 내용을 어떤 형식으로 표현해야 할지 배울것이다.


5. 시간 복잡도 함수가 log 함수를 포함할 경우 밑은 무시한다.
   모든 로그는 서로 배수 관계이다. 그래서 복잡도에 관해서 이야기할 때는 로그의 밑에 대해서는 고려하지 않아도 된다. 로그의 밑은 무시하고 로그(log) 알고리즘이라고만 말하면 된다.   
   복잡도가 log인 알고리즘은 보통 무언가를 반으로 나누거나 2를 곱한 경우에 자주 사용된다. 그래서 만약 for 반복문을 사용해서 무언가를 탐색하면서 반으로 나누거나 2를 곱할 때 복잡도는 밑이 2인 로그가 된다. 10으로 나누거나 10을 곱하게 되면 밑이 10인 로그가 된다.   
   하지만 시간 복잡도를 표시할 때에는 로그의 밑은 무시하고 그냥 log n 복잡도를 가진다고 표현한다.


6. 등호를 사용하여 표현한다.
   2n = O(n)   
   2n은 O(n)와 같다. 여기서 O(n)은 2n이 어떤 함수의 집합에 속한다는 의미를 가진다.   
   그렇기 때문에 아래와 같은 등호를 활용하여 이 관계를 수학적으로 쓸 수 있다.   
   2n = O(n),  2n ∈ O(n)


###### 알고리즘 예
- 1, c - constant time(상수시간)   
   1을 쓰거나 c를 사용한다.   
   한 번의 계산만 하면 되는 경우이다.   
   n과는 독립적인 관계를 가진다.   

- log n - trees   
   정렬이나 트리에서 많이 등장한다.

- n - once per item   
   각각의 요소마다 한 번씩 작업을 하는 경우이다.   
   리스트를 탐색할 때 사용한다.

- n^2 - compare all v all   
   모든 요소를 서로 비교하는 경우이다.
   거품 정렬이 이 경우에 해당한다.

- n! - traveling sales
   예로 모든 도시를 돌아다니는 최단 경로를 찾는 문제이다.
