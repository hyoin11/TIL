## 스택과 큐

### 들어가기 전에
배열에 대해 살펴보자.

### 학습 목표
배열과 연결 리스트의 차이점을 이해할 수 있다.

### 핵심 단어
- 배열 
- 시간 복잡도

---
#### 배열
배열에 맨 뒤에 요소를 추가하는 시간 복잡도는 O(1)(상수시간)이다. 맨 뒤의 요소를 삭제하는 시간 복잡도도 O(1)(상수시간)이다.
기본적으로 배열에서 맨 뒤에 추가하거나 제거하는 일은 상수시간에 할 수 있다.

반면 배열 맨 앞에 추가하거나 제거하는 일은 어떨까? 맨 처음에 요소를 추가하는 유일한 방법은 각 요소의 자리를 한 칸씩 옮기고 맨 앞에 추가하는 방법이다. 이 작업의 시간 복잡도는 O(n)이다. 모든 요소를 한 칸씩 옮겨야 하기 때문이다.
마찬가지로 맨 앞의 요소를 제거할 때도 맨 앞의 요소를 지우면 비게 되는데, 배열의 맨 앞은 빈 공간이 있으면 안 되기 때문에 한 칸씩 앞으로 옮겨줘야 한다. 그래서 맨 앞의 요소를 제거하는 시간 복잡도도 O(n)이다.

이것이 배열과 연결 리스트의 차이이다. 


비순차적 배열이 있을 수 있다. 이때는 요소의 순서가 중요하지 않다.  
예를 들어 단순히 요소들을 저장하고 싶을 때 사용한다. 비 순차적 배열은 맨 앞에 요소를 새로 추가하려면 맨 앞의 요소를 맨 뒤로 옮긴 뒤 맨 앞에 요소를 추가할 수 있다. 이렇게 하게 되면 맨 뒤에 추가하는 일도 상수시간이기 때문에 시간 복잡도가 상수시간이 된다. 그러나 문제는 요소들의 순서가 바뀌게 된다.

스택이나 큐를 배열 형태로 사용할 때 상수 시간으로 맨 앞에 추가하거나 제거하는 방법은 사용할 수 없다. 어쩔 수 없이 시간 복잡도가 O(n)인 방법을 선택할 수밖에 없다.

배열을 이용해 스택을 구현하려면 배열 뒤쪽을 사용하면 된다. addLast, addFirst. 그러면 상수 시간으로 작업할 수 있다. 앞쪽을 사용하게 되면 시간 복잡도가 O(n)이라 비효율적이다.

배열을 이용해 큐를 구현하려면 상수시간일 순 없다. addLast, removeFirst 혹은 addFirst, removeLast 둘 다 한쪽의 시간 복잡도가 O(n)이기 때문이다.

그래서 기본적인 배열을 가지고 시간 복잡도가 O(n)인 작업을 하지 않고서는 스택과 큐를 구현할 수 없다.


이 문제를 해결하기 위해 다른 자료구조인 조금 다른 배열을 살펴보자.

파이썬과 같은 고급 프로그래밍 언어에서는 배열을 선언하지 않고 사용할 수 있다. 양쪽 끝에서 추가하거나 제거할 때 상수 시간이 보장된다. 편법을 사용하기 때문이다. 배열을 만든 뒤 배열의 맨 앞과 맨 뒤를 앞, 뒤로 정하지 않고 중간을 앞, 뒤로 지정한다. 그리고 추가하거나 제거하면서 head와 tail 포인터를 업데이트해 준다. 앞, 뒤로 더 이상 추가할 공간이 없다면 맨 앞 또는 맨 뒤로 이동해 값을 추가하거나 제거한다.   
이런 배열을 원형 자료구조라고 한다. 양쪽 끝이 연결되어 있기 때문이다. 배열이 차있으면 head와 tail이 동일한 곳을 가리킨다. 그러나 배열이 비어있을 때도 같은 곳을 가리킨다. 그래서 배열이 차있는지 비어있는지 확인하는 방법은 인덱스만 사용하는 것이 아니라 크기도 함께 비교해줘야 한다. 배열의 요소 개수와 배열의 칸 개수가 같으면 차있는 것이다.


배열에 대해 꼭 알아야 하는 것은 맨 앞에 추가하거나 제거하는 일은 O(n)이다. 맨 뒤에 추가하거나 제거하는 일도 tail 포인터가 없다면 동일하게 O(n)이다.

배열과 연결 리스트는 차이가 있다.

배열은 전형적으로 더 빠르고 메모리도 덜 차지한다. 그러나 크기가 고정되어 있다. 또한 배열이 차게 되면 배열의 크기를 두배로 늘리고, 내용을 모두 옮겨야 한다. 그래서 배열은 적절한 크기로 만들지 않으면 연결 리스트보다 더 느릴 수 있다.
연결 리스트의 가장 큰 장점은 수용량이 정해져 있지 않다. 요소를 계속 추가해도 상관없다. 그러나 가장 큰 단점은 더 느리고 더 많은 메모리가 필요하다는 것이다.
