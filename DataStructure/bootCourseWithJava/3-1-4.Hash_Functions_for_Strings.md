## 해시 함수에서 문자열

### 들어가기 전에
문자열을 해시로 나타내는 방법을 살펴보도록 하자.

### 학습 목표
해시 충돌을 이해하고 문자열을 해시로 나타낼 수 있다.

### 핵심 단어
- 유니코드
- 해시 충돌

---
#### 해시 함수에서의 문자열
해시에 저장하고 싶은 문자열이 여러개 있을 대 이 문자열을 숫자로 바꿔야한다. 배열에 넣기 위해서는 정수를 위치로 사용하기 때문이다.  
char값을 int 변수에 저장하면 유니코드로 값을 반환하기 때문에 값이 저장된다. 옛날에는 ASCII로 사용하였는데 아스키 코드는 모든 숫자와 문자를 포함하고, 탭이나 백스페이스 같은 문자를 포함하지만 영어만 표현할 수 있어 다른 코드들이 추가되면서 유니코드로 넘어오게 되었다.  
유니코드는 모든 문자를 나타내는 단일 숫자가 있다. 0-9까지의 수들은 유니코드에서 48-57로 표현하고, A-Z는 65-90, a-z는 97-122로 표현한다.

문자열을 위한 hashCode를 구현해보자.  
한가지 방법은 각각의 문자를 유니코드로 바꾼뒤 그 숫자들의 합을 구하는 것이다. 이제 문자열을 배열에 넣을 수 있다. 그런데 예를들어 this를 변환한 값은 tish, hits를 변환한 값과 동일하게 나온다. 이말은 충돌이 여러번 일어난다는 말이다. 동일한 문자열을 가지고 같은 숫자들이 나오기 때문에 이 방법은 문자열을 표현하기에 좋은 방법이 아니다.  
다른 값이 나오게 하려면 각 문자의 위치를 사용할 수 있다. 문자의 위치를 사용하는 한가지 방법은 문자의 위치에 따라 상수를 곱하는 횟수를 다르게 하는 것이다. 이제 반환할 숫자는 각 문자의 위치에 따라 달라져 this, hits, tish 모두 다른 정수를 반환한다.  
```java
public int hashCode(String s) {
    int g = 31;
    int hash = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
        hash = g * hash + s.charAt(i);
    }
}
```
문자들의 순서에 따라 다른 값을 반환해 해시 충돌을 최소화고, 게산 속도도 빠르게 해준다. 계산 복잡도는 문자열의 길이에 따라 다르다. 데이터가 많으면 subString을 사용해 더 작은 문자열로 계산하는 방법도 있다.

여기서 상수를 31로 사용하는 이유는 뭘까?  
Java에서 hashCode() 함수를 살펴보면 size가 31인것을 확인할 수 있다. 이와 비슷하게 해시 테이블의 사이즈는 소수(prime number)인 경우가 많다.  
해시 테이블의 크기에 소수를 사용하는 것은 전통적이다. 소수를 사용하면 전통적으로 모든 버켓을 고르게 사용할 수 있는 가능성이 높아지게 되고, 해시 충돌의 가능성도 줄일 수 있게 된다.  

31을 사용하는 이유는 31이 2^5보다 1이 작기 때문이다. 31과 곱셈을 해야 할 때 곱셈을 아래와 같이 시프트(shift) 연산과 빼기로 대체할 수 있다.
```
31 * i == (i << 5) - i
```
일반적으로 곱셈 연산보다 시프트 연산과 뺄셈이 더 빠르기 때문에 이는 효율적이다.

소수를 꼭 사용해야 하는 것은 아니나, 소수를 사용하면 많은 이점이 있다.  


> 참고
> https://code-lab1.tistory.com/271#:~:text=%ED%95%B4%EC%8B%9C%20%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98%20%ED%81%AC%EA%B8%B0%EC%97%90,~length%2D1%EA%B9%8C%EC%A7%80%EC%9D%B4%EB%8B%A4.
